---
layout: post
title:  "Megahit"
date:   2015-01-29
comments: true
---

What are all the cool kids using to assemble these days? Megahit. Let's see how it compares to the iterative assembly I've been looking at.

Compiling and running megahit is a fairly straight-forwrd affair. Simply download and make:

~~~~
git clone https://github.com/voutcn/megahit.git
cd megahit
make
~~~~

Running is also pretty easy. To see a full list of options just run ./megahit -h. I ran two different assemblies, one on the data after [digital normalization]() and one on the trimmed only reads.

~~~~
megahit -m 45e9 -r combined_001.trimmed.fq.keep.abundfilt --cpu-only -l 100 -o combined_001.trimmed_megahit

megahit -m 45e9 -r combined_001.trimmed.fq --cpu-only -l 100 -o combined_001.trimmed_NO_DIGINORM_megahit
~~~~

Results from the diginorm data:

~~~~
N50: 3782
N90: 301
total contigs: 33071
average length: 1057 bp
trimmed average length: 1051 bp
greater than or equal to 100:  33071
shortest conting: 200 bp
longest contig: 203757 bp
total length: 34.981981 Mb
~~~~

Results from the trimmed only data:

~~~~
N50: 3785
N90: 299
total contigs: 33459
average length: 1050 bp
trimmed average length: 1044 bp
greater than or equal to 100:  33459
shortest conting: 200 bp
longest contig: 203757 bp
total length: 35.147425 Mb
~~~~

Wow, that's quite an improvement over the velvet iterative assembly:

~~~~
N50: 151
N90: 95
total contigs: 630314
average length: 162 bp
trimmed average length: 162 bp
greater than or equal to 100:  463142
shortest conting: 41 bp
longest contig: 77860 bp
total length: 102.485338 Mb
~~~~

Or is it?! Look at that difference in total length. This actually looks a lot like the high k values I looked at originally. So, now what? Let's look at how much information the assembly contains. I like to do this by seeing how many reads map on to the assembled contigs.

Diginorm megahit:

~~~~
2225357 (30.73%) aligned 0 times
4622374 (63.83%) aligned exactly 1 time
394121 (5.44%) aligned >1 times
69.27% overall alignment rate
~~~~


Trimmed only megahit:

~~~~
2441753 (30.52%) aligned 0 times
5046520 (63.08%) aligned exactly 1 time
511727 (6.40%) aligned >1 times
69.48% overall alignment rate
~~~~

Velvet iterative assembly:

~~~~
1540532 (19.26%) aligned 0 times
5749071 (71.86%) aligned exactly 1 time
710397 (8.88%) aligned >1 times
80.74% overall alignment rate
~~~~

About 10% more reads aligned with the velvet iterative approach and it doesn't seem to matter much if we use digital normalization. Both megahit and the velvet iterative approach are iterative assemblies, one of the main differences is megahit goes from small kmer to large whereas the velvet iterative assembly goes from large to small. I prefer the large to small iterations because If you have a high k-mer value you're likely to get a more accurate assembly at the cost of losing some data. Going high to low, you get lower in accuracy, but you're also using less data at each step so your lower accuracy assembles are a smaller portion of the data. Furthermore, with a low k-mer you're likely to align stuff over the k-mer distance but if it doesn't align further down the read then you have a misalignment and create a bubble in the graph. With a large k-mer you don't see as many misalignments or bubbles so you know you're getting an accurate alignment. I prefer this approach because it seems like you're maximizing high accuracy assemblies.

Let's try another assembly with megahit, this time keeping the iterations the same as with the velvet assemblies, 21 to 49 by 2.

Diginorm:

~~~~
total contigs: 38769
average length: 894 bp
trimmed average length: 892 bp
greater than or equal to 100:  38769
shortest conting: 200 bp
longest contig: 77569 bp
total length: 34.679071 Mb
~~~~

Trimmed only:

~~~~
total contigs: 39982
average length: 870 bp
trimmed average length: 869 bp
greater than or equal to 100:  39982
shortest conting: 200 bp
longest contig: 34859 bp
total length: 34.808913 Mb
~~~~

It looks like the kmer range 21 to 49 doesn't have a big impact one way or the other over the default values.

One last assembly. This time I ran the velvet iterative assembly but in reverse, going from small to large (21 to 49).

~~~~
N50: 130
N90: 62
total contigs: 919187
average length: 112 bp
trimmed average length: 112 bp
greater than or equal to 100:  398196
shortest conting: 41 bp
longest contig: 4561 bp
total length: 103.483892 Mb
~~~~

It's still better than megahit but not quite as good as the high to low iterative assembly.
